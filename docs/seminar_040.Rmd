---
title: 'Семинар 4. Факторный анализ'
date: 'Июнь, 7, 2018'
output:
  html_document:
    keep_md: no
    number_sections: yes
    toc: yes
lang: ru-RU
editor_options:
  chunk_output_type: console
---



```{r}
library(tidyverse) # обработка данных, графики...
library(skimr)# описательные статистики
library(rio) # импорт фантастического количества форматов данных

library(cluster) # кластерный анализ
library(factoextra) # визуализации kmeans, pca,
library(dendextend) # визуализация дендрограмм

library(corrplot) # визуализация корреляций

library(broom) # метла превращает результаты оценивания моделей в таблички

library(naniar) # визуализация пропущенных значений
library(visdat) # визуализация пропущенных значений

library(patchwork) # удобное расположение графиков рядом

library(nycflights13) # данные о полётах в Нью-Йорке
```



# Про внутригрупповые и межгрупповые дисперсии :)


Снова возьмём данные по потреблению протеинов Европе из книги [Practial Machine Learning Cookbook](https://github.com/PacktPublishing/Practical-Machine-Learning-Cookbook/blob/master/Chapter%2003/Data/Europenaprotein.csv).
Загрузим их и посмотрим описательные статистики.

```{r}
protein <- import('Europenaprotein.csv')
skim(protein)
```

Спрячем текстовую переменную `Country` в названия строк.
Затем отмасштабируем все оставшиеся числовые переменные с помощью функции `scale()`.
На этот раз мы используем `mutate_all`, а не `mutate_if`,
так как заранее спрятали текстовую переменную в названия строк :)

```{r}
protein_no_country <- protein %>%
   column_to_rownames(var = 'Country') %>%
   mutate_all(~ as.vector(scale(.)))
```

Дополнение в виде функции `as.vector` нужно потому, что функция `scale` возвращает матрицу,
а каждый столбец должен быть вектором :)



Выполним кластеризацию методом k-средних с помощью функции `kmeans`.

В качестве аргументов укажем отмасштабированные данные `protein_no_country` и количество кластеров `centers`.
Берём три кластера!
Сохраним результат кластеризации в список `k_means_protein`.

```{r}
k_means_protein <- kmeans(protein_no_country, centers = 3)
k_means_protein
```


TODO: Подробнее про межгрупповые дисперсии :)
Сюда добавить пару формул!!!



Как понять, сколько кластеров брать оптимально?
Один из способов сделать это — воспользоваться командой `fviz_nbclust` из пакета `factoextra`.


```{r}
g1 <- fviz_nbclust(protein_no_country, kmeans, method = 'wss') +
  labs(subtitle = 'Elbow method')
g1
```

TODO: подробнее про оси! Дадим русские подписи осям!




```{r}
g2 <- fviz_nbclust(protein_no_country, kmeans, method = 'silhouette') +
  labs(subtitle = 'Silhouette method')
g2
```




```{r}
g3 <- fviz_nbclust(protein_no_country, kmeans, method = 'gap_stat') +
  labs(subtitle = 'Gap statistic method')
g3
```




# Иерархическая кластеризация

Другой способ разбить данные на группы — иерархическая кластеризация.
Но, в отличие от метода k-средних, она работает с матрицей расстояний,
поэтому первым делом посчитаем её!
Для этого будем использовать функцию `dist()`.
Передадим ей стандартизированные данные и укажем явно, как считать расстояния с помощью аргумента `method`.
О всех остальных опциях можно узнать в справке.

```{r}
protein_dist <- dist(protein_no_country, method = 'euclidian')
```

Расстояния тоже можно визуализировать!
Сделаем это командой `fviz_dist` из пакета `factoextra`.

```{r}
fviz_dist(protein_dist)
```




* Упражнение 13.




Посчитайте матрицу расстояний для таблицы `usa_stand` и визуализируйте её.

```{r}
# usa_dist <- dist(___, method = 'euclidian')
# fviz_dist(___)
```

Полученную матрицу расстояний можно передадать функции `hclust()`, которая кластеризует данные.
Однако в пакете `factoextra` есть функция `hcut()`, которая работает с исходными данными.
Будем использовать её и попросим выделить четыре кластера в аргументе `k`.


```{r}
protein_hcl <- hcut(protein_no_country, k = 4)
```

С помощью функции `fviz_dend` визуализируем результат кластеризации.
Укажем несколько аргументов, чтобы сделать дендрограмму красивее,
а полный перечень найдётся в справке.

```{r}
fviz_dend(protein_hcl,
          cex = 0.5, # размер подписи
          color_labels_by_k = TRUE) # цвет подписей по группам
```

Выявленные кластеры можно добавить к исходным данным!
```{r}
protein_plus2 <- mutate(protein, cluster = protein_hcl$cluster)
glimpse(protein_plus2)
```


* Упражнение 14.

- Сделайте иерархическую кластеризацию с четыремя группами на данных об арестах.

- Визуализируйте результат кластеризации и сделайте подписи цветными.

```{r}
# usa_hcl <- hcut(___, k = ___)
# fviz_dend(___,
#          cex = 0.5, # размер подписи
#          color_labels_by_k = ___) # цвет подписей по группам
```

Иерархичская кластеризация полезна и для визуализаций корреляций.
Если в функции `corrplot()` из одноимённого пакета указать аргумента `order = hclust`,
то мы получим сгруппированные по кластерам переменные.
Для красоты добавим ещё один аргумент — `addrect = 3`.
Он обведёт прямоугольниками указанное число кластеров.

```{r}
protein_cor <- cor(protein_no_country)
corrplot(protein_cor, order = 'hclust', addrect = 3)
```

* Упражнение 15.

Визуализируйте корреляции в данных об арестах `usa` и сгруппируйте их по двум кластерам.
Замените кружочки на квадраты, передав аргументу `method` значение `shade`.

```{r}
# usa_cor <- cor(___)
# corrplot(___, order = ___, addrect = ___, ___ = ___)
```

* Упражнение 16.

Добавьте к исходным данным `usa` кластеры, полученные с помощью иерархической кластеризации:
```{r}
# usa_plus2 <- mutate(___, cluster = ___)
# glimpse(___)
```

Визуализации [кластеров в известных наборах данных] (https://cran.r-project.org/web/packages/dendextend/vignettes/Cluster_Analysis.html)

Ура! :)
