---
title: 'Семинар 2. '
date: 'May 22, 2018'
output:
  html_document:
    keep_md: no
    number_sections: yes
    toc: yes
lang: ru-RU
editor_options:
  chunk_output_type: console
---

# Гремучая смесь R и маркдаун

В нашем документе смешан код R внутри сереньких блоков и текст с разметкой маркдаун.
Эту смесь можно превратить в готовый документ,
нажав на клубок ниток со словом `Knit` прямо над документом.

Попробуйте кликнуть `Knit`:)

Будьте осторожны при редактировании R-маркдаун!
Например, если Вовочка удалит один закрывающий разделитель,
то компьютер будет воспринимать человеческий текст как команды R и выдаст ошибку.

Основные опции блоков кода:
  - message=TRUE/FALSE - выводить ли в отчёт *сообщения*
  - warning=TRUE/FALSE - выводить ли в отчёт *предупреждения*
  - echo=TRUE/FALSE - копировать ли в отчёт сами команды R
  - eval=TRUE/FALSE - выполнять ли команды внутри блока кода
  - "Самый важный шмат кода" - название блока кода :)

Подробнее про фантастические возможности R+маркдаун: `Help` - `Cheatsheets` - `R markdown`.

Сделайте свой Rstudio уютненьким: `Tools` - `Global Options` - `Appearance` :)

# Работа с очень качественными переменными.

В R есть много типов переменных, например:
  - количественные (double, dbl)
  - целочисленные (integer, int)
  - дата и время (datetime, dttm)
  - логические (logical, lgl)
  - качественные/категориальные/факторные (factor, fctr)
  - текстовые (character, chr)

Существенной разницы между текстовыми и качественными нет.
Отличия качественных от текстовых:
  - ограничено количество значений, скажем только "зима", "весна", "лето", "осень"
  - можно задать порядок "магистр" > "бакалавр" > "школьник"
  - занимают меньше места в памяти

Подключаем нужные пакеты и вперёд!
```{r}
library(tidyverse) # обработка данных, графики...
library(vcd) # графики для качественных переменных
library(skimr) # описательные статистики
library(rio) # импорт фантастического количество форматов данных
```

Узнаём частотность каждой категории переменную цвет, `color`:
```{r}
table(diamonds$color)
```

Или получаем список категорий без количеств:
```{r}
levels(diamonds$color)
```

Попробуем объединить три категории в одну: "D", "E", "F" в "United":
```{r}
diamonds2 <- mutate(diamonds, color = fct_collapse(color, United = c('D', 'E', 'F')))
table(diamonds2$color)
```

Упражнение 1.

Объедините категории "Premium" и "Ideal" огранки `cut` в категорию "Best"
```{r}
diamonds3 <- mutate(diamonds, cut = fct_collapse(___, ___))
table(diamonds3$cut)
```


# Таблицы сопряжённости

Загрузим данные по зарплатам со страницы [UCI](http://archive.ics.uci.edu/ml/machine-learning-databases/adult/).
И смотрим на них:

```{r}
adult <- import('adult.rds') # загружаем данные
glimpse(adult)
```

Мы видим, что названий в файле нет и переменные называются `V1`, `V2` :)
Полное описание есть в тексте [UCI](http://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.names).

Мы обратим внимание на две переменных: `V2` - сектор и `V15` - зарплату.
Для удобства мы их отберём и переименуем:

```{r}
adult2 <- select(adult, sector = V2, wage = V15)
glimpse(adult2)
skim(adult2)
```

Благодаря функции `skim()` можно увидеть, что эти переменные принимают 9 и 2 уникальных значений соответственно.

Для качественных переменных можно создавать таблицы сопряжённости.
По строкам указываются значения одной качественной переменной, по столбцам — другой,
а на пересечении стоит количество наблюдений.

Таблицу сопряжённости можно создать командой `table()`:
```{r}
table(adult2$sector, adult2$wage)
```

Девять значений - довольно много для ясной визуализации!

Но мы уже знаем, как объединять переменные,
поэтому всех трудящихся на государство разичать не будем.
Также объединим в одну категорию предпринимателей, значения `Self-emp-not-inc`, `Self-emp-inc`.


```{r}
adult3 <- mutate(adult2, sector = fct_collapse(sector, Gov = c('State-gov', 'Federal-gov', 'Local-gov')))
adult4 <- mutate(adult3, sector = fct_collapse(secto, Self_emp = c('Self-emp-not-inc', 'Self-emp-inc')))
skim(adult4)
```

Строим более компактную таблицу сопряжённости:

```{r}
ctable <- table(adult4$sector, adult4$wage, dnn = c('Сектор', 'Зарплата'))
ctable
```


Чтобы визуализировать созданную нами таблицу сопряжённости, можно использовать команду `mosaic()` из пакета `vcd`.
В качестве аргумента пердаём саму таблицу сопряжённости, а также указываем опции:
  - `shade = TRUE`, чтобы график был цветным;
  - `legend = TRUE`, чтобы появилась легенда.

```{r}
mosaic(ctable, shade = TRUE, legend = TRUE)
```

Осталось только выяснить, можно ли считать зарплату и сектор независимыми признаками.
Это можно сделать с помощью теста на независимость командой `chisq.test()`.

```{r}
chisq.test(ctable)
```

- Какой вывод можно сделать? Зависимы или независимы признаки?

Упражнение ???.

Для упражнения возьмём встроенный набор данных об исследовании лечения артрита.
- Посмотрите на описательные статистики. Сколько наблюдений в наборе?
- Какие признаки взяты? Сколько уникальных значений принимают факторные переменные?
- Составьте таблицы сопряжённости для столбцов `Treatment` и `Improved`. Укажите названия переменных.
<!--
для каждого пола.
- Для этого нужно просто добавить название третьего столбца в функцию `table()`.
-->
- Постройте мозаичный график `mosaic()` для получившейся таблицы сопряжённости.
- Проведите тест на независимость признаков `Treatment` и `Improved` используя оператор "затем"

```{r}
dta <- Arthritis
___
new_ctable <- table(___, ___, dnn = c("___", "___"))
new_ctable
mosaic(___, shade = ___, ___ = ___)

new_ctable %>% ___() # применяем к таблице тест на независимость
```

Упражнение ???

Опишите словами, что изображено на графике:
```{r}
mosaic(data = Arthritis, ~ Sex + Treatment + Improved, shade = TRUE, legend = TRUE)
```


# Корреляционная матрица

Возьмём встроенный набор данных про автомобили `mtcars`.
Напоминалка: посмотреть описание данных можно, набрав в консоли `?mtcars`.
Команда `cor()` поможет нам легко посчитать корреляции!

```{r}
glimpse(mtcars)
cars_cor <- cor(mtcars)
cars_cor
```

Если вдруг нужна корреляция не Пирсона, а Кендалла или Спирмена,
добавьте аргумент `method = 'kendall'` или `method = 'spearman'`.

Для визуализации корреляционной матрицы понадобится команда `corrplot()` из одноимённого пакета.
В справке (`?corrplot`) указаны все её аргументы — настраивать можно всё, что угодно,
от формы кружочков до количества знаков после запятой.

Всего лишь несколько вариантов:

```{r}
corrplot(cars_cor) # график с аргументами по умолчанию
corrplot(cars_cor, method = 'number') # график со значениями корреляции
corrplot(cars_cor, method = 'color', type = 'upper') # только правая верхняя часть
corrplot.mixed(cars_cor) # можно миксовать!
```

Красивые примеры из [виньетки пакета](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html).


Упражнение ???.

Возьмём таблицу `airquality`, ежедневные измерения качества воздуха в Нью-Йорке в 1973 году. Подробности в справке :)
- Сколько наблюдений и переменных в наборе данных `airquality`? Есть ли пропуски в данных?
- Посчитайте корреляции, игнорируя пропущенные значения
- Визуализируйте корреляции: значения должны быть только ниже диагонали, внутри графика должны стоять эллипсы.
Вся необходимая информация есть в справке!

```{r}
skim(___)
cmatrix <- cor(___, use = 'pairwise.complete.obs') # игнорируем пропущенные значения
cmatrix
corrplot(___, method = '___', type = '___')
```


# Обработка данных

Таблицы можно создавать и самим c помощью функции `tibble()`.

```{r}
mx <- tibble(ID = c('A', 'B', 'C', 'D', 'E'),
             x = c(1, 2, 4, 1, 8))
mx
```

Упражнение ???.

Создайте таблицу `my`, с двумя столбцами: `ID` и `y`, и пятью значениями в каждом.
Столбец `y` можно заполнить числами произвольно.

```{r}
my <- tibble(ID = c('A', 'C', 'D', 'F', 'E'),
             y = c(___))
my
```

Таблицы можно соединять! Существует четыре способа сделать это:
- `left_join(x, y, by = 'colname')` сохраняет все наблюдения в таблице `x`
- `right_join(x, y, by = 'colname')` сохраняет все наблюдения в таблице `y`
- `full_join(x, y, by = 'colname')` сохраняет наблюдения из обеих таблиц
- `inner_join(x, y, by = 'colname')` объединяет только те строки обеих таблиц, в которых нет пропущенных наблюдений

Экспериментируем!

```{r}
left_join(mx, my, by = 'ID')
right_join(mx, my, by = 'ID')
inner_join(mx, my, by = 'ID')
full_join(mx, my, by = 'ID')
```

- Сколько наблюдений получается в объединённой таблице в каждом случае?

Упражнение ???.

Часто в таблицах есть несколько совпадающих столбцов, по которым их можно объединить.
В этом упражнении нужно объединить таблицы `flights` и `weather` из набора данных о вылетах из Нью-Йорка.
- 'Бросьте взгляд' на обе таблицы. Какие столбцы совпадают?
- Присоедините к таблице `flights` таблицу `weather` с помощью функции  `left_join()`.
В качестве аргумента `by` используйте вектор из названий общих столбцов: `year`, `month`, `day`, `hour` и `origin`.
- Сколько наблюдений в объединённой таблице?
- Проверьте, что всё получилось :)
- Повторите второй пункт, но используя `inner_join()`. Сколько наблюдений в получившейся таблице?

```{r}
glimpse(___)
___

left <- left_join(___, ____, by = c('year', 'month', 'day', 'hour', 'origin'))
glimpse(___)

inner <- inner_join(___, ___, ___)
___
```



Таблицы бывают длинными и широкими. В широких для каждого признака есть свой столбец.

```{r}
gdp <- import('gdp.xls') # ВВП по источникам доходов
glimpse(gdp) # надо перевернуть?
gdp
```

Чтобы превратить широкую таблицу в длинную, нужна функция `melt()` из пакета `reshape2`.

```{r}
long_gdp <- melt(gdp)
glimpse(long_gdp)
```

Чтобы сдлеать обратное — перевести длинную таблицу  в широкую — понадобится функция `dcast()`.
Помимо самих данных, в ней нужно указать формулу для переменных,
значение какой переменной должно стоять внутри таблицы (аргумент `value.var`) и как её агрегировать (`fun.aggregate`).

```{r}
dcast(diamonds, cut ~ color, value.var = "price", fun.aggregate = mean)
```

Упражнение ???.

Из данных про воздух в Нью-Йорке `airquality` сделайте сначала длинную таблицу,
а из получившейся — широкую.

```{r}
air_long <- melt(___, id = c('Month', 'Day')) # id оставлеет указанные столбцы
air_long
air_wide <- dcast(___, Day + Month ~ ___) # вместо пропуска должна быть переменная с несколькими значениями
air_wide
```

# Графики

Вместо устаревшего ящика с усами мы будем строить скрипичный график (violin plot) командой `geom_viloin()` из пакета `ggplot2`.
Для примера возьмём данные про машины `mtcars` и визулизируем распределение расхода бензина на милю (`mpg`) в зависимости от количества цилиндров.

```{r}
ggplot(mtcars, aes(factor(cyl), mpg)) +
  geom_violin() +
  labs(x = 'Цилиндры', y = 'Мощность', title = 'Машины')
```

С помощью функции `facet_grid()` можно разбить эти графики на два в зависимости от того,
ручная или автоматическая коробка передач стоит в автомобиле. 

```{r}
ggplot(mtcars, aes(factor(cyl), mpg)) +
  geom_violin() +
  facet_grid(am ~ .)
  labs(x = 'Цилиндры', y = 'Мощность', title = 'Машины')
```

+ упражнения + про объединение диаграмм


Ура :)
