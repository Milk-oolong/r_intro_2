---
title: 'Семинар 2. '
date: 'May 22, 2018'
output:
  html_document:
    keep_md: no
    number_sections: yes
    toc: yes
lang: ru-RU
editor_options:
  chunk_output_type: console
---

# Гремучая смесь R и маркдаун

В нашем документе смешан код R внутри сереньких блоков и текст с разметкой маркдаун.
Эту смесь можно превратить в готовый документ,
нажав на клубок ниток со словом `Knit` прямо над документом.

Попробуйте кликнуть `Knit`:)

Будьте осторожны при редактировании R-маркдаун!
Например, если Вовочка удалит один закрывающий разделитель,
то компьютер будет воспринимать человеческий текст как команды R и выдаст ошибку.

Основные опции блоков кода:
  - message=TRUE/FALSE - выводить ли в отчёт *сообщения*
  - warning=TRUE/FALSE - выводить ли в отчёт *предупреждения*
  - echo=TRUE/FALSE - копировать ли в отчёт сами команды R
  - eval=TRUE/FALSE - выполнять ли команды внутри блока кода
  - "Самый важный шмат кода" - название блока кода :)

Подробнее про фантастические возможности R+маркдаун: `Help` - `Cheatsheets` - `R markdown`.

Сделайте свой Rstudio уютненьким: `Tools` - `Global Options` - `Appearance` :)

# Работа с очень качественными переменными.

В R есть много типов переменных, например:
  - количественные (double, dbl)
  - целочисленные (integer, int)
  - дата и время (datetime, dttm)
  - логические (logical, lgl)
  - качественные/категориальные/факторные (factor, fctr)
  - текстовые (character, chr)

Существенной разницы между текстовыми и качественными нет.
Отличия качественных от текстовых:
  - ограничено количество значений, скажем только "зима", "весна", "лето", "осень"
  - можно задать порядок "магистр" > "бакалавр" > "школьник"
  - занимают меньше места в памяти

Подключаем нужные пакеты и вперёд!
```{r}
library(tidyverse) # обработка данных, графики...
library(vcd) # графики для качественных переменных
library(skimr) # описательные статистики
```

Узнаём частотность каждой категории переменную цвет, `color`:
```{r}
table(diamonds$color)
```

Или получаем список категорий без количеств:
```{r}
levels(diamonds$color)
```

Попробуем объединить три категории в одну: "D", "E", "F" в "United":
```{r}
diamonds2 <- mutate(diamonds, color = fct_collapse(color, United = c('D', 'E', 'F')))
table(diamonds2$color)
```

Упражнение 1.

Объедините категории "Premium" и "Ideal" огранки `cut` в категорию "Best"
```{r}
diamonds3 <- mutate(diamonds, cut = fct_collapse(___, ___))
table(diamonds3$cut)
```


# Таблицы сопряжённости

Для качественных переменных можно создавать таблицы сопряжённости. По строкам указываются значения одной количественной переменной, по столбцам — другой, а на пересечении стоит количество наблюдений с соответсвующими признаками. Таблицу сопряжённости можно создать командой `table()`, где в качестве аргументов нужно указть столбцы данных.

В следующем примере использованы данные о зарплатах. Их полное описание можно найти на сайте [UCI](http://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.names).
В этом наборе нам понадобятся не все переменные, а только информация о секторе и расе.
Используя функцию `glimpse()`, можно без труда определить, что нужные столбцы называются `V2` и `V15`. А благодаря функции `skim()` можно увидеть, что эти переменные принимают 9 и 2 уникальных значений соответственно. 9 —  довольно много для ясной визуализации!
Но мы уже знаем, как объединять переменные, поэтому всех трудящихся на государство разичать не будем. Также объединим в одну категорию предпринимателей, значения `Self-emp-not-inc`, `Self-emp-inc`.

```{r}
adult <- readRDS('adult.rds') # загружаем данные формата rds
glimpse(adult) # находим названия нужных столбцов
skim(adult)

adult <- mutate(adult, V2 = fct_collapse(V2, Gov = c('State-gov', 'Federal-gov', 'Local-gov')))
adult <- mutate(adult, V2 = fct_collapse(V2, Self_emp = c('Self-emp-not-inc', 'Self-emp-inc')))
ctable <- table(adult$V2, adult$V15, dnn = c('Сектор', 'Зарплата'))
ctable
```

Чтобы визуализировать созданную нами таблицу сопряжённости, можно использовать команду `mosaic()` из пакета `vcd`, который мы подключили в самом начале. В качестве аргумента пердаём саму таблицу сопряжённости, а также указываем параметры `shade=TRUE`, чтобы график был цветным, и `legend=TRUE`, чтобы появилась легенда.

```{r}
mosaic(ctable, shade=TRUE, legend=TRUE)
```

Осталось только выяснить, можно ли считать зарплату и сектор независимыми признаками. Это можно сделать с помощью теста на независимость командой `chisq.test()`. Её аргумент —  таблица сопряжённости.

```{r}
chisq.test(ctable)
```

- Какой вывод можно сделать?

Упражнение ???.

Для упражнения возьмём встроенный набор данных об исследовании лечения артрита.
- Посмотрите на описательные статистики. Сколько наблюдений в наборе? Какие признаки взяты? Сколько уникальных значений принимают факторные переменные?
- Составьте таблицы сопряжённости для столбцов `Treatment` и `Improved` для каждого пола. Для этого нужно просто добавить название третьего столбца в функцию `table()`. Укажите название строк и столбцов для них.
- Постройте мозаичный график `mosaic()` для получившейся таблицы сопраяжённотси.
- Проведите тест на независимость признаков `Treatment` и `Improved`.

```{r}
dta <- Arthritis
___
new_ctable <- table(___, ___, dta$Sex, dnn = c(___, ___, ___))
new_ctable
mosaic(___, shade = ___, ___ = ___)

table(___, ___)  # сначала создаём таблицу сопряжённости, а затем...
  %>% chisq.test() # применяем к ней тест на независимость
```


# Корреляционная матрица

В R совсем легко построить корреляционную матрицу! Продемонстрируем это на встроенном наборе данных о характеристиках автомобилей `mtcars`. Напоминалка: посмотреть описание данных можно, набрав в консоли `?mtcars`. Чтобы построить матрицу корреляций, воспользуемся командой `cor()`. По умолчанию, считается корреляция Пирсона, но если вдруг вам нужна корреляция Кендалла или Спирмена, добавьте аргумент `method = 'kendall'` или `method = 'spearman'` соответсвтенно.

```{r}
glimpse(mtcars)
cars_cor <- cor(mtcars)
cars_cor
```

Для визуализации корреляционной матрицы понадобится команда `corrplot()` из одноимённого пакета. В справке (`?corrplot`) указаны все её аргументы — настраивать можно всё, что угодно, от формы кружоччков до количества знаков после запятой в значениях корреляции.

```{r}
corrplot(cars_cor) # график с аргументами по умолчанию
corrplot(cars_cor, method = 'number') # график со значениями корреляции
corrplot(cars_cor, method = 'color', type = 'upper') # только правая верхняя часть
corrplot.mixed(cars_cor) # можно миксовать!
```


Упражнение ???.

Для упражнения взяты ежедневные измерения качества воздуха в Нью-Йорке с мая по сентябрь 1973. Подробности в справке :)
- Посмотрите на сами данные, которые уже лежат в переменной `airquality`
- Постройте корреляционную матрицу, игнорируя пропущенные значения, и выведите её в консоль
- Визуализируйте построенную матрицу: значения должны быть только ниже диагонали, внутри графика должны стоять эллипсы. Вся необходимая информация есть в справке!

```{r}
glimpse(___)
cmatrix <- cor(___, use = 'complete.obs') # игнорируем пропущенные значения
corrplot(___, method = ___, type = ___)
```


# Обработка данных

Таблицы можно создавать и самим c помощью функции `tibble()`.

```{r}
mx <- tibble(ID = c('A', 'B', 'C', 'D', 'E'),
             x = c(1, 2, 4, 1, 8))
mx
```

Упражнение ???.

Создайте таблицу `my`, с двумя столбцами: `ID` и `y`, и пятью значениями в каждом.
Второй столбец можно заполнить произвольно.

```{r}
my <- tibble(ID = c('A', 'C', 'D', 'F', 'E'),
             y = c(4, 3, 9, 4, 2))
my
```

Ещё таблицы можно соединять! Существует четыре способа сделать это:
- `left_join(x, y, by = 'colname')` сохраняет все наблюдения в таблице `x`
- `right_join(x, y, by = 'colname')` сохраняет все наблюдения в таблице `y`
- `full_join(x, y, by = 'colname')` сохраняет наблюдения из обеих таблиц
- `inner_join(x, y, by = 'colname')` объединяет только те строки обеих таблиц, в которых нет пропущенных наблюдений

Экспериментируем!

```{r}
left_join(mx, my, by = 'ID')
right_join(mx, my, by = 'ID')
inner_join(mx, my, by = 'ID')
full_join(mx, my, by = 'ID')
```

Упражнение ???.

Часто в таблицах есть несколько совпадающих столбцов, по которым их можно объединить. В этом упражнении нужно объединить таблицы `flights` и `weather` из набора данных о вылетах из Нью-Йорка.
- 'Бросьте взгляд' на обе таблицы. Какие столбцы совпадают?
- Присоедините к таблице `flights` таблицу `weather` с помощью функции  `left_join()`. В качестве аргумента `by` используйте вектор из названий общих столбцов: `year`, `month`, `day`, `hour` и `origin`. Сколько наблюдений в объединённой таблице?
- Проверьте, что всё получилось :)
- Повторите второй пункт, но используя `inner_join()`. Сколько наблюдений в получившейся таблице?

```{r}
glimpse(___)
___

left <- left_join(___, ____, by = c('year', 'month', 'day', 'hour', 'origin'))
glimpse(___)

inner <- inner_join(___, ___, ___)
___
```



Таблицы бывают длинными и широкими. В широких для каждого признака есть свой столбец.

```{r}
gdp <- import('gdp.xls') # ВВП по источникам доходов
glimpse(gdp) # надо перевернуть?
gdp
```

Чтобы превратить широкую таблицу в длинную, нужна функция `melt()` из пакета `reshape2`.

```{r}
long_gdp <- melt(gdp)
glimpse(long_gdp)
```

Чтобы сдлеать обратное — перевести длинную таблицу  в широкую — понадобится функция `dcast()`. Помимо самих данных, в ней нужно указать формулу для переменных, значение какой переменной должно стоять внутри таблицы (аргумент `value.var`) и как её агрегировать (`fun.aggregate`).

```{r}
dcast(diamonds, cut ~ color, value.var = "price", fun.aggregate = mean)
```

Упражнение ???.

Из данных про воздух в Нью-Йорке `airquality` сделайте сначала длинную таблицу,
а из получившейся — широкую.

```{r}
air_long <- melt(___, id = c('Month', 'Day')) # id оставлеет указанные столбцы
air_long
air_wide <- dcast(___, Day + Month ~ ___) # вместо пропуска должна быть переменная с несколькими значениями
air_wide
```

# Графики

Вместо устаревшего ящика с усами мы будем строить violin plot командой `geom_viloin()` из пакета `ggplot2`. Для примера возьмём данные про машины `mtcars` и визулизируем распределение расхода бензина на милю (`mpg`) в зависимости от количества цилиндров.

```{r}
ggplot(mtcars, aes(factor(cyl), mpg)) +
  geom_violin() +
  labs(x = 'Цилиндры', y = 'Мощность', title = 'Машины')
```

Можно разбить эти графики на два в зависимости от того, ручная или автоматическая коробка передач стоит в автомобиле. Это делается с помощью функции `facet_grid()`.

```{r}
ggplot(mtcars, aes(factor(cyl), mpg)) +
  geom_violin() +
  facet_grid(am ~ .)
  labs(x = 'Цилиндры', y = 'Мощность', title = 'Машины')
```

+ упражнения + про объединение диаграмм


Ура :)
