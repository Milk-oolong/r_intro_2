---
title: 'Домашнее задание 3.'
date: 'May 31, 2018'
output:
  html_document:
    keep_md: yes
    number_sections: yes
    toc: yes
lang: ru-RU
editor_options:
  chunk_output_type: console
---

В третьей домашке будем разбираться с млекопитающими!

Данные возьмём из пакета `VIM`. Набор называется `sleep`, и он содержит информацию о сне млекопитающих. 

Описание данных:

- BodyWgt — вес, кг

- BrainWgt — вес мозга, г

- NonD — длительность сна без сноведений, часов в день

- Dream — длительность сна со сновидениями, часов в день

- Sleep — общая длительность сна, часов в день

- Span — максимальная продолжительность жизни в годах

- Gest — длительность беременности в днях

- Pred — степень хищничества, от 1 до 5, где 5 соответсвует наибольшей вероятности быть убитым другим животным

- Exp — степень склонности ко сну, от 1 до 5, где 5 соответствует наибольшей склонности

- Danger — общий индекс опасности, от 1 до 5, где 5 соответствует наибольшей опасности

* **Упражнение 0.**

Загрузите необходимые пакеты и скройте все сообщения и предупреждения.
За "все" отвечает опция `global_options`, а остальное нужно вспомнить :)

```{r global_options, message=FALSE, warning=FALSE}
library(tidyverse) # обработка данных, графики...
library(skimr)# описательные статистики
library(rio) # импорт фантастического количества форматов данных
library(cluster) # кластерный анализ
library(factoextra) # визуализации kmeans, pca,
library(dendextend) # визуализация дендрограмм
library(corrplot) # визуализация корреляций
library(naniar) # визуализация пропущенных значений
library(visdat) # визуализация пропущенных значений
library(patchwork) # удобное расположение графиков рядом
library(VIM) # данные о сне млекопитающих
```


* ещё одно **Упражнение 0.** :)

Посмотрите на описательные статистики данных `sleep`.

- Сколько наблюдений в данных?

- Сколько переменных?

- Есть ли пропущенные значения?

```{r}
skim(sleep)
```


* **Упражнение 1.**

Постройте диаграмму рассеяния для веса млекопитающего `BodyWgt` и веса его мозга `BrainWgt`. 
Раскрасьте точки в соответвии со степенью склонности ко сну `Exp`, но помните, что на самом деле эта переменная факторная!
Также не забудьте подписать оси и придумать клёвое название.
Для удобства оси графика будем строить в логарифмах — за это отвечают слои `scale_x_log10()` и `scale_y_log10()`.

Для построения графика используйте данные `sleep2`.

```{r}
sleep2 <- mutate(sleep, Exp = factor(Exp))

ggplot(data = sleep2) +
  geom_point(aes(x = BodyWgt, y = BrainWgt, color = Exp)) +
  scale_x_log10() + # для удобства отмасштабируем оси
  scale_y_log10() + 
  labs(x = 'Логарифм массы тела', y = 'Логарифм массы мозга', title = 'Клёвое название!')
```

* **Упражнение 2.**

Нарисуйте гистограмму логарифма веса мозга млекопитающих для каждой категории склонности ко сну. Как всегда, подпишите оси и добавьте название.

Для построения графика используйте данные `sleep2`.

```{r}
ggplot(data = sleep2) +
  geom_histogram(aes(x = log(BrainWgt))) +
  facet_grid(Exp ~ .) +
  labs(x  = 'Масса мозга', title = 'Вес мозга млекопитащих')
```

* **Упражнение 3.**

Визуализируйте пропуски в данных `sleep`:

1) С помощью функции `vis_miss`, и сгруппируйте их по кластерам;

2) С помощью функции `gg_miss_var`, и количество пропусков считайте в процентах.

```{r}
vis_miss(sleep,  cluster = TRUE)
gg_miss_var(sleep, show_pct = TRUE)
```

* **Упражнение 4.**

Удалите все строки, содержащие пропуски, и сохраните результат в переменную `sleep_remove`.

- Сколько наблюдений осталось?

```{r}
sleep_remove <- drop_na(sleep)
skim(sleep_remove)
```

* **Упражнение 5.**

Заполните пропуски в данных с помощью функции `replace_na` следующим образом:

- длительность сна без сновидений `NonD` средним значением;

- длительность сна со сновидениями `Dream` медианным значением;

- продолжительность жизни `Span` — минимальным;
 
- общую длительность сна `Sleep` — числом 11;

- длительность беременности — числом 90;

и проверьте, что всё получилось :)

```{r}
sleep_replace <- replace_na(data = sleep, 
                            replace = list(NonD = mean(sleep$NonD, na.rm = TRUE), 
                                           Dream = median(sleep$Dream, na.rm = TRUE), 
                                           Span = min(sleep$Span, na.rm = TRUE), 
                                           Sleep = 11, 
                                           Gest = 90))

skim(sleep_replace)
```

* **Упражнение 6.**

Приступим к кластерному анализу!

Первым шагом отмасштабируйте все столбцы `sleep_replace` с числовыми значениями так, чтобы получившиеся данные остались в формате  `data.frame`. 
Сохраните их в переменную `sleep_stand`.
Затем сделайте кластерный анализ методом k-средних, выбрав произвольное количество кластеров.
И наконец, визуализируйте результат!

```{r}
sleep_stand <- mutate_if(sleep_replace, is.numeric, ~ as.vector(scale(.)))
skim(sleep_stand)

sleep_kmeans <- kmeans(sleep_stand, centers = 2)

fviz_cluster(object = sleep_kmeans, data = sleep_stand, ellipse.type = 'convex')
```

* **Упражнение 7.**

Найдите оптимальное число кластеров.
Если оно не совпало с выбранным вами, перезапустите предыдущий кусок кода, изменив нужный параметр функции `kmeans`.

```{r}
fviz_nbclust(sleep_stand, kmeans, method = 'gap_stat') +
  labs(subtitle = 'Gap statistic method')
```


* **Упражнение 8.**

Добавьте центры кластеров к данным `sleep_replace`.

```{r}
sleep_plus <- mutate(sleep_replace, cluster = sleep_kmeans$cluster)
glimpse(sleep_plus)
```


* **Упражнение 9.**

Сделайте иерархическую кластеризацию c пятью кластерами и визуализируйте результат.

```{r}
sleep_hcl <- hcut(sleep_stand, k = 5)
fviz_dend(sleep_hcl,
          cex = 0.5, # размер подписи
          color_labels_by_k = TRUE) # цвет подписей по группам
```

* **Упражнение 10.**

Посчитайте корреляции по матрице без пропусков `sleep_replace` и визулизируйте их.
Выделите квадратами две близкие по корреляциям группы.

```{r}
sleep_cor <- cor(sleep_replace)
corrplot(sleep_cor, order = 'hclust', addrect = 2)
```

Ура, домашка сделана! :)
